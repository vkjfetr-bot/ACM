# Audit 08 12 2025

---

## 1. `acm_main.py` ‚Äì central wiring is still on the old world

### 1.1 Wrong imports for forecasting

```python
from . import correlation, outliers, forecast, river_models  # New modules
...
from core import correlation, outliers, forecast
from core import river_models
```

* There is **no `forecast.py`** in `/mnt/data` ‚Äì you only have `forecasting.py`.
* So in the real package, unless you still have an old `core/forecast.py` lying around, the import will fail or pull the wrong version.
* Even if the import succeeded, **the call site uses the old API**:

```python
forecast_ctx = {
    "run_dir": run_dir,
    "plots_dir": charts_dir,
    "tables_dir": tables_dir,
    "config": cfg,
    "enable_report": True,
}
forecast_result = forecast.run(forecast_ctx)
```

But in `forecasting.py` there is **no `run(ctx)`** ‚Äì the public entrypoints are:

```python
def run_enhanced_forecasting_sql(...)
def run_and_persist_enhanced_forecasting(...)
```

üëâ **Blocker:** `acm_main` is calling a function and module that no longer match the new design. Forecasting + RUL are never invoked via the new pipeline.

**Direction to fix:**

* Change the import to the new module:

  ```python
  from core import forecasting  # or: from . import forecasting
  ```

* Replace the `forecast.run(...)` block with a **SQL-aware call**:

  Conceptually:

  ```python
  if SQL_MODE and sql_client and equip_id and run_id:
      forecasting.run_and_persist_enhanced_forecasting(
          sql_client=sql_client,
          equip_id=equip_id,
          run_id=run_id,
          config=cfg,
          output_manager=output_manager,
          tables_dir=tables_dir,
          equip=equip,
          current_batch_time=win_end,
          sensor_data=score_numeric,   # if you want physical sensor forecasting
      )
  ```

* Only keep `forecast_ctx` / `plots_dir` if you still want **file-mode charts**; otherwise, let `run_and_persist_enhanced_forecasting` handle tables + any charts.

---

### 1.2 RUL is only reachable *through* forecasting, and never directly

* `rul_engine.py` is **not imported in `acm_main.py`** at all.
* It *is* imported in `forecasting.py`:

  ```python
  from core import rul_engine  # Unified RUL estimation engine
  ...
  return rul_engine.run_rul(...)
  ```

So if forecasting is never correctly called, **RUL is never called either**.

üëâ **Blocker:** RUL is entirely hidden behind `run_enhanced_forecasting_sql(...)`, which itself is never wired to `acm_main`.

**Direction to fix:**

* Once you fix the call to `forecasting.run_and_persist_enhanced_forecasting(...)`, **RUL will be invoked from there**.
* If you want a separate RUL step, you could also call `rul_engine.run_rul(...)` explicitly after scores + health timeline are ready, but with the new design you don‚Äôt strictly need that ‚Äì it‚Äôs already integrated into enhanced forecasting.

---

### 1.3 Health timeline fallback is CSV-only ‚Üí RUL can‚Äôt see data

In the analytics fallback block in `acm_main`:

```python
# Fallback to basic tables
if 'fused' in frame.columns:
    health_df = pd.DataFrame({
        'timestamp': frame.index.strftime('%Y-%m-%d %H:%M:%S'),
        'fused_z': frame['fused'],
        'health_index': 100.0 / (1.0 + frame['fused'] ** 2)
    })
    output_manager.write_dataframe(health_df, tables_dir / "health_timeline.csv")
```

* This writes **only CSV**, no SQL table name, so `write_dataframe` will **not** hit the database.
* But `rul_engine.run_rul()` pulls health from **SQL ONLY**:

  ```python
  health_df, data_quality = load_health_timeline(
      sql_client=sql_client,
      equip_id=equip_id,
      run_id=run_id,
      output_manager=output_manager,
      cfg=cfg,
  )
  ...
  if health_df is None or health_df.empty:
      raise RuntimeError("Health timeline unavailable")
  ```

üëâ **Blocker:** If the main OutputManager analytics path fails and you drop into fallback, **ACM_HealthTimeline in SQL is never populated**, so RUL aborts with ‚ÄúHealth timeline unavailable‚Äù.

**Direction to fix:**

* In the fallback, use the same SQL table as the main path:

  ```python
  output_manager.write_dataframe(
      health_df,
      tables_dir / "health_timeline.csv",
      sql_table="ACM_HealthTimeline",
      add_created_at=True,
  )
  ```

* Or, alternatively, change `load_health_timeline` in `rul_engine.py` to **accept a CSV fallback via OutputManager cache** ‚Äì but the quicker fix is to write SQL even in fallback.

---

### 1.4 Possible hard import-time failure: `river_models`

`acm_main.py` imports `river_models`:

```python
from . import correlation, outliers, forecast, river_models
...
from core import river_models
```

There is **no `river_models.py`** in `/mnt/data`. If it‚Äôs also missing in your `core` package, importing `acm_main` will crash before anything runs.

* This will block **everything** (detections, regimes, and thus forecasting/RUL).

**Direction to fix:**

* Either add a stub `core/river_models.py` with a no-op `RiverTAD` implementation or
* Guard its use behind config and import conditionals, or
* Temporarily disable river by commenting out import + usage until you‚Äôre ready.

---

## 2. `forecasting.py` ‚Äì new engine is SQL-only and not compatible with the old call

Key things about this file:

* Public APIs:

  ```python
  def run_enhanced_forecasting_sql(...)
  def run_and_persist_enhanced_forecasting(...)
  ```

* It expects:

  * a **SqlClient**
  * a real **EquipID + RunID**
  * the global **config dict**
  * **OutputManager** + `tables_dir` for persistence

* It calls `rul_engine.run_rul(...)` internally to compute:

  * `ACM_HealthForecast_TS`
  * `ACM_FailureForecast_TS`
  * `ACM_RUL_TS`
  * `ACM_RUL_Summary`
  * `ACM_RUL_Attribution`
  * `ACM_MaintenanceRecommendation`

* Then, `run_and_persist_enhanced_forecasting` maps logical names ‚Üí SQL tables:

  ```python
  ef_sql_map = {
      "health_forecast_ts": "ACM_HealthForecast",
      "failure_forecast_ts": "ACM_FailureForecast",
      "failure_hazard_ts": "ACM_FailureForecast",
      "detector_forecast_ts": "ACM_DetectorForecast_TS",
      "sensor_forecast_ts": "ACM_SensorForecast",
      "rul_summary": "ACM_RUL",
      "maintenance_recommendation": "ACM_MaintenanceRecommendation",
  }
  ```

üëâ **Blockers inside forecasting itself:**

1. **This code will never run until `acm_main` calls it correctly** (see section 1.1).
2. When it *does* run, it will try to write to SQL tables like `ACM_HealthForecast`, `ACM_FailureForecast`, `ACM_RUL` etc ‚Äì but these are **not in OutputManager.ALLOWED_TABLES** (see next section), so `_bulk_insert_sql` will raise `ValueError("Invalid table name: ‚Ä¶")`.

**Direction to fix:**

* Wire `acm_main` into `run_and_persist_enhanced_forecasting` (section 1.1).

* Add all new forecast / RUL tables to `ALLOWED_TABLES` in `output_manager.py`:

  At minimum:

  ```python
  'ACM_HealthForecast', 'ACM_FailureForecast',
  'ACM_DetectorForecast_TS', 'ACM_SensorForecast',
  'ACM_HealthForecast_TS', 'ACM_FailureForecast_TS',
  'ACM_RUL_TS', 'ACM_RUL_Summary',
  'ACM_RUL_Attribution', 'ACM_MaintenanceRecommendation',
  'ACM_RUL_LearningState',
  ```

* Make sure these tables actually exist in SQL (we can do DDL later if you want).

---

## 3. `rul_engine.py` ‚Äì logically OK, but blocked by missing health + table whitelist

`rul_engine.run_rul(...)` is reasonably self-contained:

* It builds `RULConfig` from `config_row["forecasting"]`.

* Cleans up old forecast runs via:

  ```python
  for table in ["ACM_HealthForecast_TS", "ACM_FailureForecast_TS"]:
      ...
  ```

* Loads health timeline via `load_health_timeline(...)` (SQL-first, no CSV fallback).

* Loads / saves **learning state** in `ACM_RUL_LearningState`.

* Produces multiple tables in the `tables` dict (see the `ACM_...` names above).

üëâ **The only real blockers here are external:**

1. **No SQL `ACM_HealthTimeline` when analytics fallback runs** ‚Üí Step 4 fails (`Health timeline unavailable`).
2. **OutputManager won‚Äôt allow the forecast/RUL table names** (ALLOWED_TABLES miss them) ‚Üí `_bulk_insert_sql` throws.

Once those two are fixed, RUL should run **as soon as** `forecasting.run_enhanced_forecasting_sql(...)` is invoked with a live SqlClient + valid config.

---

## 4. `output_manager.py` ‚Äì forecast/RUL tables not whitelisted, fallback is file-only

Two key issues:

### 4.1 ALLOWED_TABLES doesn‚Äôt know about forecast/RUL tables

Current `ALLOWED_TABLES`:

```python
ALLOWED_TABLES = {
    'ACM_Scores_Wide','ACM_Episodes',
    'ACM_HealthTimeline','ACM_RegimeTimeline',
    ...
    'ACM_SensorHotspots','ACM_SensorHotspotTimeline',
}
```

No `ACM_HealthForecast`, `ACM_FailureForecast`, `ACM_RUL`, `ACM_RUL_TS`, etc.

`_bulk_insert_sql` enforces this:

```python
if table_name not in ALLOWED_TABLES:
    raise ValueError(f"Invalid table name: {table_name}")
```

üëâ **Blocker:** Even if forecasting runs, any attempt to persist its tables will throw an exception here.

**Direction:** Extend `ALLOWED_TABLES` to include all forecast/RUL tables you actually want to persist (see list in ¬ß2 & ¬ß3).

---

### 4.2 Health/regime fallback writes only CSV

As seen in ¬ß1.3, your fallback block writes:

* `health_timeline.csv`
* `regime_timeline.csv`

**without** SQL table names.

Meanwhile, the main analytics path (inside OutputManager) does:

```python
health_df = self._generate_health_timeline(scores_df)
self.write_dataframe(
    health_df,
    tables_dir / "health_timeline.csv",
    sql_table="ACM_HealthTimeline" if force_sql else None,
    add_created_at=True,
)
```

So:

* If full analytics succeeds ‚Üí all good, `ACM_HealthTimeline` exists.
* If full analytics **fails** ‚Üí fallback runs, but **no SQL writes**, and RUL can‚Äôt proceed.

**Direction:**

* In the fallback, call `write_dataframe` with `sql_table="ACM_HealthTimeline"` and `ACM_RegimeTimeline` as appropriate, mirroring the main path.

---

## 5. `regimes.py` ‚Äì labeling is wired, but errors can kill the run

### 5.1 Feature basis + label flow

`acm_main.py` does:

1. Build basis:

   ```python
   regime_basis_train, regime_basis_score, regime_basis_meta = regimes.build_feature_basis(
       train_features=train,
       score_features=score,
       raw_train=train_numeric,
       raw_score=score_numeric,
       pca_detector=pca_detector,
       cfg=cfg,
   )
   ```

   * `build_feature_basis` is robust: if PCA or raw tags fail, it **falls back** to a few feature columns.

2. Label regimes:

   ```python
   with T.section("regimes.label"):
       regime_ctx = {...}
       regime_out = regimes.label(score, regime_ctx, {"frame": frame}, cfg)
   ```

3. Use labels for per-regime calibration, transitions, etc.

So in principle, **regime detection is wired in**.

### 5.2 Hard failure path in `label(...)`

In `regimes.label(...)`:

```python
if basis_train is not None and basis_score is not None:
    # do full modern regime labeling
    ...
    return out

if bool(_cfg_get(cfg, "regimes.allow_legacy_label", False)):
    return _legacy_label(...)
raise RuntimeError("[REGIME] Regime model unavailable and legacy path disabled (regimes.allow_legacy_label=False)")
```

* If for some reason `basis_train` or `basis_score` ends up `None` (e.g. upstream error, unexpected column issues), and
* `regimes.allow_legacy_label` is **False** (default unless set in config),

then `label(...)` raises a **RuntimeError** which is **not caught** in `acm_main` ‚Äì this will:

* Stop scoring,
* Prevent OutputManager from running,
* So you get **no regimes, no health timeline, no forecasting, no RUL**.

üëâ **Blocker:** Any hidden error in the basis / labeling flow + `regimes.allow_legacy_label=False` ‚Üí hard stop.

**Directions:**

* In your `config_table.csv`, either:

  * Make sure `regimes.allow_legacy_label=True` as a safety net **until regime basis is rock-solid**, or
  * Add a `try/except` around `regimes.label(...)` in `acm_main` that logs and **falls back** to un-regimed calibration instead of killing the whole run.

* Also verify `regimes.feature_basis.raw_tags` list only contains actual columns that exist in `train_numeric` / `score_numeric` to minimize basis failures.

### 5.3 Regime outputs not always persisted

* The **full** regime analytics (summary, transitions, dwell stats, etc.) are generated by OutputManager (`_generate_regime_timeline`, `_generate_regime_transition_matrix`, etc.).
* If OutputManager‚Äôs main analytics block fails and you drop to fallback, you only get a basic **CSV `regime_timeline.csv`**, and **no SQL `ACM_RegimeTimeline` / RegimeStats**, so Grafana won‚Äôt see regime info.

This is the same pattern as health timeline: **regimes can be ‚Äúrunning‚Äù but not visible** because persistence is broken.

---

## 6. `health_tracker.py` & `state_manager.py` ‚Äì implemented, but unused

* `health_tracker.py` defines a nice `HealthTimeline` class with:

  * `load_from_sql()`
  * `quality_check()`
  * `detect_regime_shift()`
  * `get_statistics()`

* `state_manager.py` defines `StateManager` with:

  * SQL-backed forecast state (`ACM_ForecastingState`, `ACM_AdaptiveConfig`)
  * ROWVERSION optimistic locking, retries, etc.

üëâ **At the moment:**

* **Nothing imports these modules** in the uploaded files (`acm_main.py`, `forecasting.py`, `rul_engine.py`).
* So they **don‚Äôt block anything**, but they also **don‚Äôt improve** anything yet.

They become relevant once you plug them into `forecasting.py` / `rul_engine.py` for:

* Smarter health loading (instead of the current `load_health_timeline`),
* Tracking long-term forecast state and adaptive tuning.

For now, the forecasting/RUL failures you‚Äôre seeing are *not* because of these modules; they‚Äôre just unused.

---

## 7. `model_persistence.py` ‚Äì not blocking forecasts/RUL directly

From what‚Äôs visible and from your earlier notes:

* `model_persistence.py` is used to cache detector models (PCA, Mahalanobis, IForest, GMM, OMR).
* Regime models are **persisted separately** via `regimes.save_regime_model(...)` in `acm_main`.
* Forecast & RUL use **their own** SQL tables, not this file.

üëâ No direct blockers for forecasting/RUL here; the issues are all in wiring & OutputManager.

---

## TL;DR ‚Äì What is actually preventing things from ‚Äúrunning properly‚Äù?

1. **Forecasting not called correctly**

   * `acm_main.py` still imports `forecast` and calls `forecast.run(ctx)`
   * New engine is `forecasting.run_and_persist_enhanced_forecasting(...)` and expects SQL context.

2. **RUL hidden behind forecasting**

   * RUL only runs via `rul_engine.run_rul(...)` inside `forecasting.py`.
   * Since forecasting is never invoked properly, **RUL never triggers**.

3. **Health timeline missing in SQL on fallback**

   * When analytics fail, fallback writes only CSV, not `ACM_HealthTimeline`.
   * RUL‚Äôs `load_health_timeline` is SQL-only ‚Üí it bails out.

4. **Forecast/RUL tables blocked by OutputManager**

   * New tables (`ACM_HealthForecast`, `ACM_FailureForecast`, `ACM_RUL_*`, etc.) are **not in ALLOWED_TABLES**, so any SQL insert will error out.

5. **Regime labeling can hard-fail**

   * If regime basis breaks and `regimes.allow_legacy_label=False`, `regimes.label(...)` raises and kills scoring before outputs/forecasts/RUL.
   * Even when regimes run, if OutputManager analytics crashes, regime outputs never reach SQL/Grafana.

6. **New helpers (health_tracker/state_manager) are not wired in**

   * They don‚Äôt block anything, but also mean your ‚Äúv10‚Äù design isn‚Äôt actually active in the live pipeline.
