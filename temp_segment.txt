    Compute RUL via three independent paths and select dominant.
    
    Path 1 (Trajectory): Mean health forecast crosses failure threshold
    Path 2 (Hazard): Failure probability exceeds threshold (e.g., 50%)
    Path 3 (Energy): Reserved for future anomaly energy integration
    
    Args:
        health_forecast: DataFrame with [Timestamp, ForecastHealth, CI_Lower, CI_Upper]
        failure_curve: DataFrame with [Timestamp, FailureProb, ThresholdUsed]
        current_time: Current timestamp
        cfg: Configuration
    
    Returns:
        Dict with:
        - rul_trajectory_hours: RUL from trajectory path (or None)
        - rul_hazard_hours: RUL from hazard path (or None)
        - rul_energy_hours: RUL from energy path (or None)
        - rul_final_hours: Selected RUL
        - lower_bound_hours: Lower confidence bound
        - upper_bound_hours: Upper confidence bound
        - dominant_path: Which path was used ("trajectory", "hazard", or "energy")
    """
    Console.info("[RUL-Multipath] Computing RUL via multiple paths...")
    
    # Path 1: Trajectory crossing (mean forecast < threshold) - Expected RUL (50th percentile)
    rul_trajectory = None
    if health_forecast is not None and not health_forecast.empty:
        trajectory_crossing = health_forecast[
            health_forecast["ForecastHealth"] <= cfg.health_threshold
        ]
        if not trajectory_crossing.empty:
            t1 = trajectory_crossing.iloc[0]["Timestamp"]
            rul_trajectory = (t1 - current_time).total_seconds() / 3600
            Console.info(f"[RUL-Multipath] Trajectory crossing (mean) at {t1}, RUL={rul_trajectory:.1f}h")
        else:
            Console.info("[RUL-Multipath] No trajectory crossing within forecast horizon")
    
    # Path 2: Conservative (90th percentile) - CI_Lower crossing (10% chance of earlier failure)
    rul_conservative = None
    if health_forecast is not None and not health_forecast.empty:
        conservative_crossing = health_forecast[
            health_forecast["CI_Lower"] <= cfg.health_threshold
        ]
        if not conservative_crossing.empty:
            t2 = conservative_crossing.iloc[0]["Timestamp"]
            rul_conservative = (t2 - current_time).total_seconds() / 3600
            Console.info(f"[RUL-Multipath] Conservative crossing (CI_Lower) at {t2}, RUL={rul_conservative:.1f}h")
        else:
            Console.info("[RUL-Multipath] No conservative crossing within forecast horizon")
    
    # Path 3: Optimistic (10th percentile) - CI_Upper crossing (90% chance of earlier failure)
    rul_optimistic = None
    if health_forecast is not None and not health_forecast.empty:
        optimistic_crossing = health_forecast[
            health_forecast["CI_Upper"] <= cfg.health_threshold
        ]
        if not optimistic_crossing.empty:
            t3 = optimistic_crossing.iloc[0]["Timestamp"]
            rul_optimistic = (t3 - current_time).total_seconds() / 3600
            Console.info(f"[RUL-Multipath] Optimistic crossing (CI_Upper) at {t3}, RUL={rul_optimistic:.1f}h")
        else:
            Console.info("[RUL-Multipath] No optimistic crossing within forecast horizon")
    
    # Select dominant RUL (use conservative estimate for safety-critical decisions)
    available_ruls = [r for r in [rul_trajectory, rul_conservative, rul_optimistic] if r is not None]
    
    if available_ruls:
        # Use conservative path (minimum RUL) for safety
        rul_final = min(available_ruls)
        
        # Determine dominant path
        if rul_final == rul_trajectory:
            dominant_path = "trajectory"
        elif rul_final == rul_conservative:
            dominant_path = "conservative"
        else:
            dominant_path = "optimistic"
    else:
        # No crossing detected, use max forecast horizon
        rul_final = cfg.max_forecast_hours
        dominant_path = "none"
        Console.info(f"[RUL-Multipath] No crossing detected, using max horizon: {rul_final:.1f}h")
    
    # Compute confidence bounds from CI crossings
    lower_bound = None
    upper_bound = None
    
    if health_forecast is not None and not health_forecast.empty:
        # Lower bound: CI_Lower crosses threshold
        ci_lower_crossing = health_forecast[
            health_forecast["CI_Lower"] <= cfg.health_threshold
        ]
        if not ci_lower_crossing.empty:
            t_lower = ci_lower_crossing.iloc[0]["Timestamp"]
            lower_bound = (t_lower - current_time).total_seconds() / 3600
        
        # Upper bound: CI_Upper crosses threshold
        ci_upper_crossing = health_forecast[
            health_forecast["CI_Upper"] <= cfg.health_threshold
        ]
        if not ci_upper_crossing.empty:
            t_upper = ci_upper_crossing.iloc[0]["Timestamp"]
            upper_bound = (t_upper - current_time).total_seconds() / 3600
    
    # If bounds not available, use Â±30% of RUL
    if lower_bound is None:
        lower_bound = max(0.0, rul_final * 0.7)
    if upper_bound is None:
        upper_bound = rul_final * 1.3
    
    result = {
        "rul_trajectory_hours": rul_trajectory,
        "rul_hazard_hours": rul_conservative,  # Conservative estimate
        "rul_energy_hours": rul_optimistic,  # Optimistic estimate
        "rul_final_hours": float(rul_final),
        "lower_bound_hours": float(lower_bound),
        "upper_bound_hours": float(upper_bound),
        "dominant_path": dominant_path,
    }
    
    Console.info(
